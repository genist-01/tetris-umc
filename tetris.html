<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Tetris</title>
  <style>
    body { background: #111; display: flex; justify-content: center; margin-top: 30px; }
    canvas { background: #000; border: 2px solid #fff; }
    #pauseBtn { margin: 10px 0 0 10px; font-family: monospace; padding: 2px 6px; font-size: 12px; background: #222; color: white; border: 1px solid white; cursor: pointer; }
    #pauseBtn:hover {background: #444; }
    #score { color: white; font-family: monospace; margin-left: 20px; }
    #hold { background: #222; border: 1px solid #fff; }
    #next { background: #222; border: 1px solid #fff; }
    #leaderboard { color:white; font-family: monospace; margin-left:20px; margin-top:20px; }
    #scoreTable { border-color:white; color:white; }
  </style>
</head>
<body>

      <canvas id="tetris" width="400" height="880"></canvas>
<div id="score">
  Score: 0<br>

  </div>

  <div style="margin-left: 20px; color: white; font-family: monospace;">
    <h4>Hold</h4>
    <canvas id="hold" width="80" height="80"></canvas>
  </div>

  <div style="margin-left: 20px; color: white; font-family: monospace;">
    <h4>Next</h4>
    <canvas id="next" width="80" height="240"></canvas>
  </div>

  <div id="leaderboard" >
  <h3>Leaderboard</h3>
  <table id="scoreTable" border="1" cellpadding="4" cellspacing="0">
    <thead>
      <tr><th>Name</th><th>Score</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    context.scale(40, 40); 
    
    const holdCanvas = document.getElementById('hold');
    const holdCtx = holdCanvas.getContext('2d');
    holdCtx.scale(20, 20); // same scale as the main canvas

    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');
    nextCtx.scale(20, 20);

    function arenaSweep() {
      let rowCount = 0;
      outer: for (let y = arena.length - 1; y >= 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
          if (arena[y][x] === 0) {
            continue outer;
          }
        }

        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        ++rowCount;
        ++y;
      }

      if (rowCount > 0) {
        const scoreTable = [0, 100, 300, 500, 800];
        player.score += scoreTable[rowCount] * (level + 1);
        lines += rowCount;
        level = Math.floor(lines / 10);
        dropInterval = levelSpeeds[Math.min(level, levelSpeeds.length - 1)];
        updateScore();
      }
    }


    function collide(arena, player) {
  const [m, o] = [player.matrix, player.pos];
  for (let y = 0; y < m.length; ++y) {
    for (let x = 0; x < m[y].length; ++x) {
      if (m[y][x] !== 0) {
        const ay = y + o.y;
        const ax = x + o.x;

        // Check for vertical and horizontal out-of-bounds or collision
        if (
          ay < 0 || ay >= arena.length ||
          ax < 0 || ax >= arena[0].length ||
          arena[ay][ax] !== 0
        ) {
          return true;
        }
      }
    }
  }
  return false;
}


    function createMatrix(w, h) {
      const matrix = [];
      while (h--) {
        matrix.push(new Array(w).fill(0));
      }
      return matrix;
    }

    function createPiece(type) {
      if (type === 'T') {
        return [
          [0, 0, 0],
          [1, 1, 1],
          [0, 1, 0],
        ];
      } else if (type === 'O') {
        return [
          [2, 2],
          [2, 2],
        ];
      } else if (type === 'L') {
        return [
          [0, 3, 0],
          [0, 3, 0],
          [0, 3, 3],
        ];
      } else if (type === 'J') {
        return [
          [0, 4, 0],
          [0, 4, 0],
          [4, 4, 0],
        ];
      } else if (type === 'I') {
        return [
          [0, 5, 0, 0],
          [0, 5, 0, 0],
          [0, 5, 0, 0],
          [0, 5, 0, 0],
        ];
      } else if (type === 'S') {
        return [
          [0, 6, 6],
          [6, 6, 0],
          [0, 0, 0],
        ];
      } else if (type === 'Z') {
        return [
          [7, 7, 0],
          [0, 7, 7],
          [0, 0, 0],
        ];
      }
    }

    function drawMatrix(matrix, offset) {
      matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          context.fillStyle = colors[value];
          context.fillRect(x + offset.x, y + offset.y, 1, 1);

        // Draw inner grid line
        context.strokeStyle = '#111'; // or '#333' for lighter
        context.lineWidth = 0.05;
        context.strokeRect(x + offset.x, y + offset.y, 1, 1);
      }
    });
  });
}

    function drawGrid() {
  context.strokeStyle = '#333';
  context.lineWidth = 0.05; // thin lines for visibility

  const cols = arena[0].length;
  const rows = arena.length;

  for (let x = 0; x <= cols; x++) {
    context.beginPath();
    context.moveTo(x, 0);
    context.lineTo(x, rows);
    context.stroke();
  }

  for (let y = 0; y <= rows; y++) {
    context.beginPath();
    context.moveTo(0, y);
    context.lineTo(cols, y);
    context.stroke();
  }
}

function drawGhost() {
  const ghost = {
    matrix: player.matrix,
    pos: {x: player.pos.x, y: player.pos.y}
  };

  while (!collide(arena, ghost)) {
    ghost.pos.y++;
  }
  ghost.pos.y--; // Move up one to avoid collision

  ghost.matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        context.fillStyle = colors[value] + '66'; // semi-transparent version
        context.fillRect(x + ghost.pos.x, y + ghost.pos.y, 1, 1);
      }
    });
  });
}

function drawHold() {
  holdCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height); // Clear properly
  holdCtx.scale(20, 20); // Reapply scale
  holdCtx.fillStyle = '#222';
  holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);

  if (!holdPiece) return;

  // Compute bounding box of piece
  let minX = holdPiece[0].length, maxX = 0;
  let minY = holdPiece.length, maxY = 0;

  holdPiece.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    });
  });

  const pieceWidth = maxX - minX + 1;
  const pieceHeight = maxY - minY + 1;

  const offsetX = Math.floor((4 - pieceWidth) / 2) - minX;
  const offsetY = Math.floor((4 - pieceHeight) / 2) - minY;

  holdPiece.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        holdCtx.fillStyle = colors[value];
        holdCtx.fillRect(x + offsetX, y + offsetY, 1, 1);

        holdCtx.strokeStyle = '#111';
        holdCtx.lineWidth = 0.05;
        holdCtx.strokeRect(x + offsetX, y + offsetY, 1, 1);
      }
    });
  });
}


function drawNext() {
  nextCtx.setTransform(1, 0, 0, 1, 0, 0); 
  nextCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height); 
  nextCtx.scale(20, 20); 
  nextCtx.fillStyle = '#222';
  nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

  const matrix = createPiece(pieceQueue[0]);

  // Compute bounding box
  let minX = matrix[0].length, maxX = 0;
  let minY = matrix.length, maxY = 0;

  matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    });
  });

  const pieceWidth = maxX - minX + 1;
  const pieceHeight = maxY - minY + 1;

  const offsetX = Math.floor((4 - pieceWidth) / 2) - minX;
  const offsetY = Math.floor((4 - pieceHeight) / 2) - minY;

  matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        nextCtx.fillStyle = colors[value];
        nextCtx.fillRect(x + offsetX, y + offsetY, 1, 1);

        nextCtx.strokeStyle = '#111';
        nextCtx.lineWidth = 0.05;
        nextCtx.strokeRect(x + offsetX, y + offsetY, 1, 1);
      }
    });
  });
}

    function draw() {
      context.fillStyle = '#000';
      context.fillRect(0, 0, canvas.width, canvas.height);

      drawGrid(); 
      drawMatrix(arena, {x: 0, y: 0});
      drawGhost();
      drawMatrix(player.matrix, player.pos);
    }

    function merge(arena, player) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + player.pos.y][x + player.pos.x] = value;
          }
        });
      });
    }

    function playerMove(dir) {
      player.pos.x += dir;
      if (collide(arena, player)) {
        player.pos.x -= dir;
      }
    }


    function rotate(matrix, dir) {
      for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }
      if (dir > 0) {
        matrix.forEach(row => row.reverse());
      } else {
        matrix.reverse();
      }
    }

   function playerDrop() {
     player.pos.y++;
     if (collide(arena, player)) {
       player.pos.y--;
       merge(arena, player);
       playerReset();
       arenaSweep();
      } else {
        player.score += 1; // soft drop score
      }
      dropCounter = 0;
      updateScore();
    }


    function playerHardDrop() {
      let dropDistance = 0;
      while (!collide(arena, player)) {
        player.pos.y++;
        dropDistance++;
      }
      player.pos.y--;
      player.score += dropDistance * 2;
      merge(arena, player);
      playerReset();
      arenaSweep();
      dropCounter = 0;
      updateScore();
    }


    function playerReset() {
      const pieces = 'TJLOSZI';
      player.matrix = createPiece(pieceQueue.shift());
      pieceQueue.push(getRandomPieceType());

      player.pos.y = 0;
      player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);

      holdUsed = false;
      drawHold();

      drawNext();

      if (collide(arena, player)) {
        const name = prompt("Game Over! Enter your name:");
        if (name) {
          addScore(name, player.score);
        }
        arena.forEach(row => row.fill(0));
        player.score = 0;
        
	lines = 0;
	level = 0;
	dropInterval = levelSpeeds[0];
	updateScore();
      }
    }

    // Hold piece function
    function playerHold() {
      if (holdUsed) return; // prevent multiple holds in one turn

      if (!holdPiece) {
        holdPiece = player.matrix;
        playerReset();
      } else {
        const temp = player.matrix;
        player.matrix = holdPiece;
        holdPiece = temp;
        player.pos.y = 0;
        player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
      }

      holdUsed = true;
      drawHold();
    }

    function playerRotate(dir) {
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
          rotate(player.matrix, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }
    
    let paused = false;
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;

    function update(time = 0) {
      if (!paused) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
          playerDrop();
        }
      draw();
      }
      requestAnimationFrame(update);
    }

    const colors = [
      null,
      '#FF0D72',
      '#0DC2FF',
      '#0DFF72',
      '#F538FF',
      '#FF8E0D',
      '#FFE138',
      '#3877FF',
    ];

    const arena = createMatrix(10, 22);
    
    let level = 0;
    let lines = 0;

    const levelSpeeds = [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 80, 70, 60, 50, 40, 30, 20, 15, 10, 5];

    const player = {
      pos: {x: 0, y: 0},
      matrix: null,
      score: 0
    };
    
    // Holding piece variables
    let holdPiece = null
    let holdUsed = false

    function getRandomPieceType() {
      const pieces = 'TJLOSZI';
      return pieces[Math.floor(Math.random() * pieces.length)];
}

const pieceQueue = [getRandomPieceType(), getRandomPieceType(), getRandomPieceType(), getRandomPieceType()];


    function updateScore() {
      document.getElementById('score').innerHTML =
        `Score: ${player.score}<br>Level: ${level}<br>Lines: ${lines}`;
    }


    // Controls
    document.addEventListener('keydown', event => {
      if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
        playerMove(-1);
      } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
        playerMove(1);
      } else if (event.code === 'ArrowDown' || event.code === 'KeyS') {
        playerDrop();
      } else if (event.keyCode === 81) {
        playerRotate(-1);
      } else if (event.code === 'ArrowUp' || event.code === 'KeyW') {
        playerRotate(1);
      } else if (event.code === 'Space') {
	playerHardDrop()
      } else if (event.code === 'KeyC') {
        playerHold()
      }
    });

    // Leaderboard
    const MAX_ENTRIES = 10;

    function loadScores() {
      const scores = localStorage.getItem('tetrisScores');
      return scores ? JSON.parse(scores) : [];
    }

    function saveScores(scores) {
      localStorage.setItem('tetrisScores', JSON.stringify(scores));
    }

    function addScore(name, score) {
      let scores = loadScores();
      scores.push({ name, score });
      scores.sort((a, b) => b.score - a.score);
      scores = scores.slice(0, MAX_ENTRIES);
      saveScores(scores);
      displayScores();
    }

    function displayScores() {
      const scores = loadScores();
      const tbody = document.querySelector("#scoreTable tbody");
      tbody.innerHTML = "";
      scores.forEach(({ name, score }) => {
        const row = document.createElement("tr");
        row.innerHTML = `<td>${name}</td><td>${score}</td>`;
        tbody.appendChild(row);
      });
    }

    playerReset();
    update();
    drawHold();
    displayScores();
    document.getElementById('pauseBtn').addEventListener('click', () => {
      paused = !paused;
      document.getElementById('pauseBtn').innerText = paused ? 'Resume' : 'Pause';
    });
  </script>
</body>
</html>
